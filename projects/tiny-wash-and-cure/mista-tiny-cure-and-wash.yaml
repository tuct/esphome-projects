esphome:
  name: mista-tiny-wash-and-cure

esp32:
  board: seeed_xiao_esp32c3
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
#api:
#  password: ""

#ota:
#  - platform: esphome
#    password: ""

#wifi:
#  ssid: ""
#  password: ""
#
#  # Enable fallback hotspot (captive portal) in case wifi connection fails
#  ap:
#    ssid: "Mista-Tiny-Wash-And-Cure"
#    password: "75Eh2iIhQwbl"

#captive_portal:
globals:
  - id: washRunTimeMin
    type: int
    restore_value: yes
    initial_value: '4'
  - id: cureRunTimeMin
    type: int
    restore_value: yes
    initial_value: '2'
  - id: runTimeSec
    type: int
    restore_value: no
    initial_value: '120'
select:
  - platform: template
    id: uiState
    optimistic: true
    options:
      - setMode
      - setTime
      - run
    initial_option: setMode
    on_value:
      then:
        - display.page.show: !lambda |-
            if (id(uiState).state == "setTime") {
              return id(setTimePage);
            } 
            if (id(uiState).state == "run") {
              return id(runPage);
            } 
            return id(setModePage);     
  - platform: template
    id: opmode
    optimistic: true
    options:
      - wash
      - cure
    initial_option: wash
script:
  - id: toogleMode
    then:
      - lambda: |-
          auto call = id(opmode).make_call();
          if(id(opmode).state == "wash"){
            call.set_option("cure");
          }else{
            call.set_option("wash");
          }
          call.perform();
  - id: addTime
    then:
      - lambda: |-
          if(id(opmode).state == "wash"){
            if(id(washRunTimeMin)<20)id(washRunTimeMin) += 1;
          }else{
            if(id(cureRunTimeMin)<20)id(cureRunTimeMin) += 1;
          }
      - component.update: mini_display
  - id: subTime
    then:
      - lambda: |-
          if(id(opmode).state == "wash"){
            if(id(washRunTimeMin)>1)id(washRunTimeMin) -= 1;
          }else{
            if(id(cureRunTimeMin)>1)id(cureRunTimeMin) -= 1;
          }
      - component.update: mini_display
  - id: setTimeMode
    then:
      - select.set:
          id: uiState
          option: "setTime"
  - id: run
    then:
      - lambda: |-
          if(id(opmode).state == "wash"){
            id(runTimeSec) = id(washRunTimeMin)*60;
              auto call = id(fan_wash).turn_on();
              call.perform();
          }else{
            id(runTimeSec) = id(cureRunTimeMin)*60;
            id(cure_light).turn_on().set_brightness(1.0).perform();
          }
      - select.set:
          id: uiState
          option: "run"
  - id: finished
    then:
      - lambda: |-
          if(id(opmode).state == "wash"){
              auto call = id(fan_wash).turn_off();
              call.perform();
          }else{
            id(cure_light).turn_off().perform();
          }
      - select.set:
          id: uiState
          option: "setMode"
  - id: updateRuntime
    then:
      if:
        condition: 
          lambda: 'return id(uiState).state == "run";'
        then:
          - lambda: |-
              if(id(runTimeSec)>0){
                id(runTimeSec)--;
                //reverse every 30 sec
                int runMod = id(runTimeSec) % 30;
                if(id(opmode).state == "wash" && runMod == 3){
                  auto callOff = id(fan_wash).turn_off();
                }
                if(id(opmode).state == "wash" && runMod == 0){
                  auto call = id(fan_wash).turn_on();
                  if (id(fan_wash).direction == FanDirection::FORWARD) {
                    call.set_direction(FanDirection::REVERSE);
                  } else {
                    call.set_direction(FanDirection::FORWARD);
                  }
                  call.perform();
                }
              }else{
                id(finished).execute();
              }
          - component.update: mini_display
interval:
  - interval: 1s
    then:
      - script.execute: updateRuntime

font:
  - file:
      type: gfonts
      family: Roboto
      weight: 600
    id: roboto
    size: 16
i2c:
  sda: GPIO03
  scl: GPIO04
output:
  - platform: ledc
    pin: GPIO21
    id: out_cure
  - platform: ledc
    pin: GPIO20
    id: out_wash_a
  - platform: ledc
    pin: GPIO10
    id: out_wash_b
fan:
  - platform: hbridge
    id: fan_wash
    pin_a: out_wash_a
    pin_b: out_wash_b
    decay_mode: slow   # slow decay mode (coasting) or fast decay (braking).
light:
  - platform: monochromatic
    id: cure_light
    output: out_cure
    restore_mode: ALWAYS_OFF

binary_sensor:
  - platform: gpio
    id: btn_left
    pin:
      number: GPIO05
      inverted: true
      mode:
        input: true
        pullup: true
    on_press:
      - lambda: |-
          if(id(uiState).state == "setMode"){
            id(toogleMode).execute();
          }else if(id(uiState).state == "setTime"){
            id(subTime).execute();
          }else if(id(uiState).state == "run"){
            id(finished).execute();
          }

  - platform: gpio
    id: btn_right
    pin:
      number: GPIO06
      inverted: true
      mode:
        input: true
        pullup: true
    on_press:
      - lambda: |-
          if(id(uiState).state == "setMode"){
            id(toogleMode).execute();
          }else if(id(uiState).state == "setTime"){
            id(addTime).execute();
          }else if(id(uiState).state == "run"){
            id(finished).execute();
          }
  - platform: gpio
    id: btn_ok
    pin:
      number: GPIO07
      inverted: true
      mode:
        input: true
        pullup: true
    on_press:
      - lambda: |-
          if(id(uiState).state == "setMode"){
            id(setTimeMode).execute();
          }else if(id(uiState).state == "setTime"){
            id(run).execute();
          }else if(id(uiState).state == "run"){
            id(finished).execute();
          }

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x32"
    id: mini_display
    address: 0x3C
    flip_x: false 
    flip_y: false
    pages:
      - id: setModePage
        lambda: |-
          it.print(18, 8, id(roboto), "WASH");
          it.print(86, 8, id(roboto), "CURE");
          it.circle(8, 16, 6);
          it.circle(76, 16, 6);
          //show active opMode
          if (id(opmode).state == "wash") {
            it.filled_circle(8, 16, 4);
          } 
          if (id(opmode).state == "cure") {
            it.filled_circle(76, 16, 4);
          }
      - id: setTimePage
        lambda: |-
          if (id(opmode).state == "wash") {
             it.print(0, 8, id(roboto), "WASH");
             it.printf(64, 8, id(roboto), "%02d:00", id(washRunTimeMin));  
          } 
          if (id(opmode).state == "cure") {
            it.print(0, 8, id(roboto), "CURE");
            it.printf(64, 8, id(roboto), "%02d:00", id(cureRunTimeMin));  
          }
      - id: runPage
        lambda: |-
          int runMin = id(runTimeSec)/60;
          int runSec = id(runTimeSec)%60;
          if (id(opmode).state == "wash") {
             it.print(0, 8, id(roboto), "WASH >");
          } 
          if (id(opmode).state == "cure") {
            it.print(0, 8, id(roboto), "CURE >");
          }
          it.printf(64, 8, id(roboto), "%02d:%02d", runMin,runSec);  
                  
