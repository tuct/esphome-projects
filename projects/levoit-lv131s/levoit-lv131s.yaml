#requires custom esphome version (500Khz for SPI) at the moment!
esphome:
  name: !secret name
  on_boot:
    priority: 300
    then:
      - lambda: |-
          memset(id(display_bits), 0x0, 14);
          id(display_bits)[3] = 0x03; // set power to on to force re-render
          id(update_display).execute();

esp32:
  board: az-delivery-devkit-v4
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  id: wifi_id
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  passive_scan: true
  on_connect: 
    - globals.set:
        id: wifi_connecting
        value: '100'
  on_disconnect: 
    - globals.set:
        id: wifi_connecting
        value: '0'

#
  # Enable fallback hotspot (captive portal) in case wifi connection fails
#  ap:
#   ssid: "Levoit-Lv131S Fallback Hotspot"
#    password: "OMgo8F13ZBYn"

#captive_portal:

#control display
spi:
    clk_pin: GPIO14
    mosi_pin: GPIO13
    interface: hardware

spi_device:
    id: spidev
    cs_pin: GPIO15
    data_rate: 500khz
    spi_mode: 0
    bit_order: lsb_first   

#reading btns
uart:
  rx_pin: GPIO16
  baud_rate: 990
  data_bits: 7 
  debug:
    direction: BOTH
    dummy_receiver: true
    after:
      bytes: 3
    sequence:
      - lambda:  |-
          //UARTDebug::log_hex(direction, bytes, ':'); // show serial bytes
          //ESP_LOGI("tobi","BTN1 - power press");
          if(bytes.size()==3){
            if(bytes[0]==0x1A){
               if(bytes[1]==0x1B && bytes[2]==0x5A) id(btn_power).publish_state(true); 
               if(bytes[1]==0x1B && bytes[2]==0x53) id(btn_display).publish_state(true);
               if(bytes[1]==0x1B && bytes[2]==0x5B) id(btn_sleep).publish_state(true); 
               if(bytes[1]==0x5B && bytes[2]==0x5A) id(btn_auto).publish_state(true); 
               if(bytes[1]==0x5B && bytes[2]==0x53) id(btn_fan).publish_state(true); 
               if(bytes[1]==0x5B && bytes[2]==0x52) id(btn_timer).publish_state(true);          
            }
          }
          id(btn_run_check)->stop();
          id(btn_run_check)->execute();
#ensure we turn off binary after no input
script:
  - id: btn_run_check
    mode: restart
    then:
      - delay: 90ms
      - binary_sensor.template.publish:
          id: btn_power
          state: OFF
      - lambda: |-
          if (id(btn_power).state) id(btn_power).publish_state(false); 
          if (id(btn_display).state) id(btn_display).publish_state(false);
          if (id(btn_sleep).state) id(btn_sleep).publish_state(false); 
          if (id(btn_auto).state) id(btn_auto).publish_state(false);        
          if (id(btn_fan).state) id(btn_fan).publish_state(false); 
          if (id(btn_timer).state) id(btn_timer).publish_state(false);    
  - id: update_display
    mode: single
    then:
      - lambda: |-
          uint8_t before[14];
          memcpy(before, id(display_bits), 14);

          //Power

          uint8_t bit = 0; 
          bit=3;
          if(id(fan_lv131).state){
            id(display_bits)[bit] = id(display_bits)[bit] | 0x03;
          }else{
            memset(id(display_bits), 0x0, 14); //all off, except 1 power
            id(display_bits)[bit] = id(display_bits)[bit] | 0x01;        
          }
          //all other only if power is on!
          if(id(fan_lv131).state){
            //WIFI, connnected
            bit=4;
            if (id(wifi_id).is_connected()) {
              id(display_bits)[bit] = id(display_bits)[bit] | 0x80;
              id(display_bits)[5] = id(display_bits)[5] | 0x01;
            }else{
              
              if(id(wifi_connecting) < 10){
                id(display_bits)[bit] = id(display_bits)[bit] & ~0x80;
                id(display_bits)[5] = id(display_bits)[5] & ~0x01;            
              }else{
                id(display_bits)[bit] = id(display_bits)[bit] | 0x80;
                id(display_bits)[5] = id(display_bits)[5] | 0x01;         
              }    
              id(wifi_connecting)++;        
              if(id(wifi_connecting) == 20){
                id(wifi_connecting)=0;
              }
            }  


            //Fan speed
            bit = 12;

            if (id(fan_lv131).state && id(fan_lv131).speed == 1) {
              id(display_bits)[bit] = id(display_bits)[bit] | 0x18;
            }else{
              id(display_bits)[bit] = id(display_bits)[bit] & ~0x18;
            } 
            
            if (id(fan_lv131).state && id(fan_lv131).speed == 2) {
              id(display_bits)[bit] = id(display_bits)[bit] | 0x60;
            }else{
              id(display_bits)[bit] = id(display_bits)[bit] & ~0x60;
            } 

            if (id(fan_lv131).state && id(fan_lv131).speed == 3) {
              id(display_bits)[bit] = id(display_bits)[bit] | 0x80;
              id(display_bits)[13] = id(display_bits)[13] | 0x01;
            }else{
              id(display_bits)[bit] = id(display_bits)[bit] & ~0x80;
              id(display_bits)[13] = id(display_bits)[13] & ~0x01;
            }  

            //Fan modes

            if (id(fan_lv131).get_preset_mode()  == "Auto") {
              id(display_bits)[11] = id(display_bits)[11] | 0x02;
              id(display_bits)[bit] = id(display_bits)[bit] | 0x01;              
            } else {
              id(display_bits)[11] = id(display_bits)[11] & ~0x02;
              id(display_bits)[bit] = id(display_bits)[bit] & ~0x01;
            }

            if (id(fan_lv131).get_preset_mode()  == "Sleep") {
              id(display_bits)[bit] = id(display_bits)[bit] | 0x06;      
            } else {
              id(display_bits)[bit] = id(display_bits)[bit] & ~0x06;
            }    

          }

          //only if id(display_bits) has been changed!
          if (memcmp(before, id(display_bits), 14) == 0) {
            // no change → skip SPI
            return;
          }

          //set mode
          id(spidev).enable();
          id(spidev).write_byte(0x03);
          id(spidev).disable();
          //set adr
          id(spidev).enable();
          id(spidev).write_byte(0x40);
          id(spidev).disable();
          //data
          id(spidev).enable();
          id(spidev).write_byte(0xC0);

          //log out
          int size = 14;
          char buffer[64];  // make sure it's big enough for 14 bytes
          int offset = 0;
          for (int i = 0; i < size; i++) {
              offset += sprintf(buffer + offset, "%02X ", id(display_bits)[i]);
          }
          ESP_LOGI("display", "display_bits after shift: %s", buffer);
          //logout end

          //14 bytes data
          for (int i = 0; i < 14; i++) {
            id(spidev).write_byte(id(display_bits)[i]);
          }


          id(spidev).disable();
          //cmd4
          id(spidev).enable();
          id(spidev).write_byte(0x8C);
          id(spidev).disable(); 
  - id: shift_display_right
    parameters:
      n: int
    then:
      - lambda: |-
          int size = 14;
          if (n <= 0 || n >= size) {}else{
            // Shift right using memmove
            memmove(&id(display_bits)[n], &id(display_bits)[0], size - n);

            // Fill the leftmost n bytes with 0
            for (int i = 0; i < n; i++) {
              id(display_bits)[i] = 0x00;
            }
          
          }
          //id(display_bits)[0] = 0x0F; //for test 
          // Optional: log result
          char buffer[64];  // make sure it's big enough for 14 bytes
          int offset = 0;

          //for (int i = n; i < n+2; i++) {
          for (int i = 0; i < size; i++) {
              offset += sprintf(buffer + offset, "%02X ", id(display_bits)[i]);
          }

          ESP_LOGI("display", "display_bits after shift: %s", buffer);
sensor:            
  - platform: pulse_width
    name: 'PM1-10 - 1-10μm ug/m3'
    update_interval: 30s
    id: sensor_pm
    state_class: measurement
    device_class: pm10
    unit_of_measurement: 'ug/m3'
    accuracy_decimals: 0
    pin: 
      number: GPIO21
      inverted: true
      mode:
        input: true
    filters:
      - round_to_multiple_of: 0.01
      - calibrate_linear:
          method: exact
          datapoints:
            - 0.0 -> 0.0
            - 0.05 -> 0.0
            - 0.25 -> 1.0
            - 1.1 -> 1.0
      - multiply: 300 
      - round_to_multiple_of: 1        
binary_sensor:
  - platform: template
    id: btn_power
    trigger_on_initial_state: true
    on_click:
      min_length: 50ms
      max_length: 2500ms   
      then:
        - fan.toggle: fan_lv131
        - lambda: |-
            if(id(fan_lv131).state) id(swi_display).turn_on();
  - platform: template
    id: btn_display
    on_click:
       - switch.toggle: swi_display
  - platform: template
    id: btn_sleep
  - platform: template
    id: btn_auto
  - platform: template
    id: btn_fan
  - platform: template
    id: btn_timer
# TEST code only used to identify the use leds by shifting a 1 through the full display memory!    
  - platform: gpio
    pin: 
      number: GPIO04
      inverted: true
      mode:
        input: true
        pullup: true
    name: test
    on_click: 
      - lambda: |-
          //clear all
          memset(id(display_bits), 0x00, 14);

          // Set ONLY the first byte
          id(display_bits)[0] = id(byte_loop);

          ESP_LOGI("display", "display_bits[0] = 0x%02X", id(byte_loop));
          id(shift_display_right)->execute(id(shift_offset));
          id(update_display).execute();
          // 01,02,04,08,10,20,40,80 for each byte to test leds!

          // Increment 0x00 → 0xFF → wrap
          if (id(byte_loop) >= 0x80){
            id(byte_loop) = 0x01;
            id(shift_offset)+=1;
            if(id(shift_offset)>13){
              id(shift_offset) = 0;
            }
            int start_byte = id(shift_offset);
            ESP_LOGI("display", "Byte: %d ", start_byte);
          }else{
             id(byte_loop) =  id(byte_loop)*2;
            //id(byte_loop)++;
            //id(byte_loop) = 0x41;         
          }
globals:
  - id: display_bits
    type: uint8_t[14]
    restore_value: no
  - id: shift_offset
    type: uint8_t
    restore_value: no
    initial_value: '11'
  - id: byte_loop
    type: uint8_t
    restore_value: no
    initial_value: '1'
  - id: wifi_connecting
    type: uint8_t
    restore_value: no
    initial_value: '0'

switch:
  - platform: template
    name: "Display"
    id: swi_display
    optimistic: true

fan:
  - platform: template
    name: "Fan"
    id: fan_lv131
    speed_count: 3
    preset_modes:
      - Manual
      - Auto
      - Sleep    

interval:
  - interval: 100ms
    then: 
      - script.execute: update_display
  
#interval:
#  - interval: 1000ms
#    then:
#      - lambda: |-
#          //uint8_t init[14] = {0xF0, 0x00};
#          //memcpy(id(display_bits), init, 14);
#          
#     
#        
#          // Optional: clear all first
#          memset(id(display_bits), 0x00, 14);
#
#          // Set ONLY the first byte
#          id(display_bits)[0] = id(byte_loop);
#
#          ESP_LOGI("display", "display_bits[0] = 0x%02X", id(byte_loop));
#          id(shift_display_right)->execute(id(shift_offset));
#          id(update_display).execute();
#          // Increment 0x00 → 0xFF → wrap
#          if (id(byte_loop) >= 0x80){
#            id(byte_loop) = 0x01;
#            id(shift_offset)+=1;
#            if(id(shift_offset)>13){
#              id(shift_offset) = 0;
#            }
#            int start_byte = id(shift_offset);
#            ESP_LOGI("display", "Byte: %d ", start_byte);
#
#
#          }else{
#             id(byte_loop) =  id(byte_loop)*2;
#            //id(byte_loop)++;
#            //id(byte_loop) = 0x41;         
#          }


